#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
int main(int argc, char const *argv[])
{
int p[2]; /* Дескрипторы конвейера */
int newp1, newp2, newp3; /* PID дочерних процессов */
/* Создание канала */
if (pipe(p)<0) {
printf("Ошибка создания канала\n");
return 1;
}
/* Создание 1-го дочернего процесса */
if ( (newp1=fork()) < 0 ) {
printf("Ошибка 1-го fork()\n");
return 2;
}
if (newp1==0) { /* 1-й дочерний процесс */
close(p[0]); /* Закрываем дескриптор "чтения канала" */
dup2(p[1], 1); /* Связываем канал со станд. выводом */
/* Запускаем "ls -la" */
execlp("ls", "ls", "-la", NULL);
printf("Ошибка запуска ls\n");
return 3;
}
else { /* Родительский процесс */
if ( (newp2=fork()) < 0 ) {
printf(" Ошибка 2-го fork()\n");
return 2;
}
if(newp2==0) { /* 2-й дочерний процесс */
close(p[1]); /* Закрываем дескриптор "записи" */
dup2(p[0], 0); /* Связываем канал со станд. вводом */
execlp("grep", "grep",argv[1] ,NULL); /* Запускаем "grep" */
printf("Ошибка запуска grep\n");
return 3;
}
else {
if(newp3==0){/*3-й дочерний процесс*/
 close(p[1]);/*закрываем дескриптор "записи"*/
 dup2(p[0],0); /* Связываем канал со станд. вводом*/
 execlp("sort","sort",NULL);/**/
 printf("Ошибка запуска sort\n");
 return 3;
}
}
/* Родительский процесс */
/* Последним из потомков завершится третий
(sort), поэтому ждем завершения именно его. Статус
завершения не используется (указан NULL).
Опции waitpid() также 0. */
waitpid(newp3,NULL,0);
}
